<application>
  <component name="ee.carlrobert.codegpt.state.conversations.ConversationsState">
    <option name="conversationsContainer" value="{&quot;conversationsMapping&quot;:{&quot;chat.completion&quot;:[{&quot;id&quot;:&quot;2f8c1247-756c-40f8-8199-6230bb54ea19&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;Use the following context to answer question at the end:\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\main.py\nFile Content:\n```py\r\n\&quot;\&quot;\&quot;Main module for the al-ic package. Everything happens here.\&quot;\&quot;\&quot;\r\n\r\nimport enum  # noqa: I001\r\nimport functools\r\nimport sys\r\nfrom dataclasses import dataclass\r\nfrom time import sleep\r\nfrom typing import Any\r\n\r\nimport keyboard  # type: ignore[reportMissingImports]\r\nimport typer  # type: ignore[reportMissingImports]\r\nfrom loguru import logger  # type: ignore[reportMissingImports]\r\nfrom openstack import connect, enable_logging\r\nfrom openstack.block_storage.v3.volume import Volume\r\nfrom openstack.compute.v2.flavor import Flavor\r\nfrom openstack.compute.v2.server import Server\r\nfrom openstack.connection import Connection\r\nfrom openstack.exceptions import ResourceNotFound, ResourceTimeout, SDKException\r\nfrom openstack.network.v2.network import Network\r\nfrom rich.progress import BarColumn, Progress, TextColumn, TimeRemainingColumn  # type: ignore[reportMissingImports]\r\n\r\nfrom al_ic.__about__ import __version__\r\n\r\nnon_deletable_volumes = {\&quot;migrating\&quot;, \&quot;attached\&quot;}\r\n\r\ndeletable_volumes = {\r\n    \&quot;available\&quot;,\r\n    \&quot;error\&quot;,\r\n    \&quot;error_restoring\&quot;,\r\n    \&quot;error_extending\&quot;,\r\n    \&quot;error_managing\&quot;,\r\n}\r\n\r\nLAN_NAME = \&quot;NAS-LAN\&quot;\r\n\r\n# Initialize and turn on debug logging\r\nenable_logging(debug=False, http_debug=False)\r\n\r\napp = typer.Typer()\r\n\r\n\r\nclass OpenStackConnection:\r\n    \&quot;\&quot;\&quot;\r\n    A class to manage a connection to OpenStack.\r\n\r\n    This class is a singleton, meaning it will only ever create one instance of the OpenStack connection.\r\n    This is useful when you want to make sure that only one connection is made to the OpenStack cloud in your\r\n    application.\r\n\r\n    Attributes\r\n    ----------\r\n        _instance (Connection|None): The single instance of the OpenStack connection.\r\n                                     It's initially None and gets assigned when get_instance() is called for the\r\n                                     first time.\r\n\r\n    Methods\r\n    -------\r\n        get_instance() -&gt; Connection: Returns the single instance of the OpenStack connection.\r\n                                      If it doesn't exist, it creates one.\r\n\r\n    \&quot;\&quot;\&quot;\r\n\r\n    _instance: Connection | None = None\r\n\r\n    @classmethod\r\n    def instance(cls) -&gt; Connection:\r\n        \&quot;\&quot;\&quot;\r\n        Return the single instance of the OpenStack connection.\r\n\r\n        If the connection instance doesn't exist, it creates one by connecting to the OpenStack cloud.\r\n        It also logs the connection process.\r\n\r\n        Returns\r\n        -------\r\n            Connection: The single instance of the OpenStack connection.\r\n\r\n        \&quot;\&quot;\&quot;\r\n        if cls._instance is None:\r\n            logger.info(\&quot;Connecting to OpenStack...\&quot;)\r\n            cls._instance = connect(cloud=\&quot;openstack\&quot;)\r\n            instance_name = cls._instance.name\r\n            logger.info(f\&quot;Connected to OpenStack: {instance_name}\&quot;)\r\n        return cls._instance\r\n\r\n\r\n# A list of volume names that are protected and should not be deleted.\r\n# These volumes are critical for the operation of the application and deleting them could cause issues.\r\nprotected_volumes = [\r\n    \&quot;rendernode - base\&quot;,\r\n    \&quot;rendernode - base backup\&quot;,\r\n    \&quot;juicefs-metadata-02\&quot;,\r\n    \&quot;juicefs-metadata-01\&quot;,\r\n    \&quot;s3-westcall-gateway\&quot;,\r\n    \&quot;s3-mgts-gateway\&quot;,\r\n    \&quot;s3-inetcom-gateway\&quot;,\r\n    \&quot;ic-4090-x1-00-volume\&quot;,\r\n]\r\n\r\n\r\nclass Providers(enum.StrEnum):\r\n    \&quot;\&quot;\&quot;\r\n    Enum for different providers.\r\n\r\n    This enum defines different providers such as AVANTEL, INETCOM, MGTS, and WESTCALL.\r\n    \&quot;\&quot;\&quot;\r\n\r\n    avantel = \&quot;avantel\&quot;\r\n    inetcom = \&quot;inetcom\&quot;\r\n    mgts = \&quot;mgts\&quot;\r\n    westcall = \&quot;westcall\&quot;\r\n\r\n\r\nseconds_between_instance_creation = 20\r\n\r\n\r\ndef get_gateway_networks() -&gt; list[Network]:\r\n    \&quot;\&quot;\&quot;\r\n    Retrieve gateway networks.\r\n\r\n    This function retrieves gateway networks by listing all networks and filtering out those\r\n    that do not meet a certain condition.\r\n\r\n    Returns\r\n    -------\r\n        list: A list of network objects that meet the specified condition.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n\r\n    logger.info(\&quot;Getting gateway networks\&quot;)\r\n    all_nets = conn.list_networks()\r\n    return [net for net in all_nets if str(net.name).lower() in Providers]\r\n\r\n\r\ndef get_instance_name(gpu_model: str, gpu_count: int | str, count_number: int) -&gt; str:\r\n    \&quot;\&quot;\&quot;\r\n    Return a formatted instance name.\r\n\r\n    Example: ic-4090-x1-00.\r\n    \&quot;\&quot;\&quot;\r\n    return f\&quot;ic-{gpu_model}-x{gpu_count}-{count_number:02d}\&quot;\r\n\r\n\r\n# TODO(Mike): Precache the flavors instead of getting them on the fly\r\nflavor_name_4090 = \&quot;rtx4090-1.16.96.160\&quot;\r\nflavor_name_4090_aux = \&quot;rtx4090-1.16.64.160\&quot;\r\n\r\nflavor_name_3090 = \&quot;rtx3090-1.16.96.160\&quot;\r\nflavor_name_3090_aux = \&quot;rtx3090-1.16.64.160\&quot;\r\n\r\nflavor_name_2080ti = \&quot;rtx2080ti-1.16.64.160\&quot;\r\n\r\nflavor_name_3080 = \&quot;rtx3080-1.16.64.160\&quot;\r\n\r\nflavor_name_5000 = \&quot;rtxa5000-2.16.128.160.nvlink\&quot;\r\n\r\ndefault_flavor_name = flavor_name_4090\r\n\r\ndefault_name = get_instance_name(\&quot;4090\&quot;, \&quot;1\&quot;, 0)\r\nbase_volume_name = \&quot;rendernode - base\&quot;\r\n\r\n\r\ndef get_base_volume() -&gt; Volume:\r\n    \&quot;\&quot;\&quot;\r\n    Find the base volume by name and checks if it's in use.\r\n\r\n    Returns\r\n    -------\r\n    openstack.block_storage.v3.volume.Volume: The base volume.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn: Connection = OpenStackConnection.instance()\r\n    base_volume: Volume = conn.volume.find_volume(base_volume_name)  # type: ignore[assignment] # Find a volume by name\r\n    base_volume_in_use = bool(len(base_volume.attachments))  # type: ignore[assignment]\r\n    logger.info(f\&quot;Base volume in use: {base_volume_in_use}\&quot;)\r\n    return base_volume\r\n\r\n\r\ndef create_volume_name_for_base_clone(gpu_model: str, gpu_count: int | str, count_number: int, throwaway: bool) -&gt; str:  # noqa: FBT001\r\n    \&quot;\&quot;\&quot;\r\n    Create a volume name for a base clone.\r\n\r\n    This function generates a volume name for a base clone based on the GPU model, GPU count, count number, and\r\n    whether the volume is a throwaway volume. The volume name is generated by appending the GPU model, GPU count,\r\n    and count number to the string \&quot;ic-\&quot;, and then appending a throwaway suffix (\&quot;-throwaway\&quot;) if the volume is\r\n    a throwaway volume.\r\n\r\n    Parameters\r\n    ----------\r\n    gpu_model : str\r\n        The model of the GPU.\r\n    gpu_count : int\r\n        The number of GPUs.\r\n    count_number : int\r\n        The count number of the instance.\r\n    throwaway : bool\r\n        Whether the volume is a throwaway volume.\r\n\r\n    Returns\r\n    -------\r\n    str\r\n        The generated volume name for the base clone.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    throwaway_suffix = \&quot;-throwaway\&quot; if throwaway else \&quot;\&quot;\r\n    instance_name = get_instance_name(gpu_model, gpu_count, count_number)\r\n    return f\&quot;{instance_name}{throwaway_suffix}-volume\&quot;\r\n\r\n\r\n@app.command()\r\ndef clone_base_volume(\r\n    gpu_model: str = \&quot;4090\&quot;,\r\n    gpu_count: int = 1,\r\n    count_number: int = 1,\r\n    *,\r\n    throwaway: bool = False,\r\n) -&gt; Volume | None:\r\n    \&quot;\&quot;\&quot;\r\n    Clones the base volume and returns the new volume.\r\n\r\n    Returns\r\n    -------\r\n    openstack.block_storage.v3.volume.Volume: The cloned volume.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    cloned_volume_name = create_volume_name_for_base_clone(gpu_model, gpu_count, count_number, throwaway=throwaway)\r\n    logger.info(f\&quot;Cloning base volume to '{cloned_volume_name}'\&quot;)\r\n    cloned_volume: Volume = Volume(connection=conn, name=cloned_volume_name, source_volume_id=get_base_volume().id)\r\n    cloned_volume.create(conn.volume)\r\n    while cloned_volume.status != \&quot;available\&quot;:\r\n        logger.info(f\&quot;Volume status: {cloned_volume.status}\&quot;)\r\n        possible_volume = conn.get_volume(cloned_volume.id)\r\n        if isinstance(possible_volume, Volume):\r\n            cloned_volume = possible_volume\r\n        else:\r\n            logger.error(f\&quot;Volume '{cloned_volume_name}' not found\&quot;)\r\n            return None\r\n        sleep(2)\r\n    logger.success(f\&quot;Volume status: {cloned_volume.status}\&quot;)\r\n    return cloned_volume\r\n\r\n\r\n@app.command()\r\ndef delete_volume(volume) -&gt; None | Volume:  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Delete the specified volume.\r\n\r\n    Args:\r\n    ----\r\n    volume (openstack.block_storage.v3.volume.Volume): The volume to delete.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    if isinstance(volume, str):\r\n        requested_volume = volume\r\n        volume = Volume.find(conn.volume, name_or_id=volume)\r\n        if not volume:\r\n            logger.error(f\&quot;Volume '{requested_volume}' is not found\&quot;)\r\n            return None\r\n    if isinstance(volume, Volume):\r\n        if volume.name in protected_volumes:\r\n            logger.warning(f\&quot;Volume '{volume.name}' is protected and cannot be deleted.\&quot;)\r\n            return None\r\n        return volume.delete(conn.volume)\r\n    return None\r\n\r\n\r\n@app.command()\r\ndef delete_throwaway_volumes(status: str = \&quot;available\&quot;) -&gt; None:\r\n    \&quot;\&quot;\&quot;Delete all throwaway volumes.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    logger.info(f\&quot;Deleting all throwaway volumes with status '{status}'\&quot;)\r\n    all_volumes = conn.list_volumes()\r\n    for volume in all_volumes:\r\n        if \&quot;-throwaway\&quot; in str(volume.name):\r\n            if volume.status in deletable_volumes and volume.status not in non_deletable_volumes:\r\n                delete_volume(volume)\r\n                logger.info(f\&quot;Deleted volume '{volume.name}'\&quot;)\r\n            else:\r\n                logger.warning(f\&quot;Volume '{volume.name}' has status '{volume.status}' and cannot be deleted.\&quot;)\r\n\r\n\r\ndef create_instance(\r\n    flavor: Flavor,\r\n    volume_name: str = \&quot;\&quot;,\r\n    gpu_model: str = \&quot;4090\&quot;,\r\n    gpu_count: int = 1,\r\n    count_number: int = 0,\r\n    *,\r\n    use_existing_volume: bool = True,\r\n    throwaway: bool = False,\r\n    wait_for_instance_creation_status: bool = False,\r\n) -&gt; Server | None:\r\n    \&quot;\&quot;\&quot;Create an instance with the default flavor and image.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    volume_auto_removal_condition = throwaway\r\n    if volume_auto_removal_condition:\r\n        logger.warning(\&quot;Volume will be automatically removed after instance termination\&quot;)\r\n\r\n    message_prefix = \&quot;Start of creating instance for \&quot;\r\n    instance_details = f\&quot;ic-{gpu_model}x{gpu_count}-{count_number:02d}\&quot;\r\n    logger.info(f\&quot;{message_prefix}{instance_details}\&quot;)\r\n\r\n    logger.info(f\&quot;Using flavor '{flavor.name}'\&quot;)\r\n\r\n    if not volume_name and use_existing_volume:\r\n        volume_name = create_volume_name_for_base_clone(gpu_model, gpu_count, count_number, throwaway)\r\n\r\n    # Abort if the volume is protected\r\n    if volume_name in protected_volumes and volume_auto_removal_condition:\r\n        logger.error(f\&quot;Volume '{volume_name}' is protected. Aborting instance creation.\&quot;)\r\n        return None\r\n\r\n    # Attempt to find the volume if a name is specified or determined\r\n    if volume_name:\r\n        logger.info(f\&quot;Looking for volume '{volume_name}'\&quot;)\r\n        volume = conn.volume.find_volume(volume_name)  # type: ignore[reportAttributeAccessIssue]\r\n        if volume:\r\n            logger.info(f\&quot;Found volume '{volume_name}'\&quot;)\r\n        else:\r\n            logger.warning(f\&quot;Volume '{volume_name}' not found\&quot;)\r\n    else:\r\n        volume = None\r\n\r\n    # If no volume is found or volume_name wasn't set, create a new one\r\n    if not volume_name or not volume:\r\n        volume_name = volume_name or create_volume_name_for_base_clone(\r\n            gpu_model,\r\n            gpu_count,\r\n            count_number,\r\n            throwaway=throwaway,\r\n        )\r\n        logger.info(f\&quot;Creating new volume '{volume_name}'\&quot;)\r\n        volume = clone_base_volume(gpu_model, gpu_count, count_number, throwaway=throwaway)\r\n    if not volume:\r\n        logger.error(f\&quot;Failed to create volume '{volume_name}'\&quot;)\r\n        return None\r\n\r\n    if volume.status != \&quot;available\&quot;:\r\n        logger.error(f\&quot;Volume '{volume_name}' is not available. Aborting instance creation.\&quot;)\r\n        return None\r\n\r\n    networks = get_local_networks()\r\n    if not networks:\r\n        logger.error(\&quot;Local network not found. Aborting instance creation.\&quot;)\r\n        return None\r\n    (local_network, gateway_networks) = networks\r\n\r\n    message_prefix = \&quot;Requesting an node instance \&quot;\r\n    instance_details = f\&quot;{gpu_model}x{gpu_count}-{count_number:02d}\&quot;\r\n    logger.info(f\&quot;{message_prefix}{instance_details}with volume '{volume.name}'\&quot;)\r\n    instance: Server = conn.create_server(\r\n        name=get_instance_name(gpu_model, gpu_count, count_number),\r\n        description=f\&quot;Render node for {gpu_model}x{gpu_count}\&quot;,\r\n        flavor=flavor,\r\n        boot_volume=volume,\r\n        network=[local_network, gateway_networks[0]],\r\n        terminate_volume=volume_auto_removal_condition,\r\n        wait=wait_for_instance_creation_status,\r\n        timeout=60 * 5,\r\n    )\r\n\r\n    while True:\r\n        instance: Server = conn.get_server(instance.id)  # type: ignore[assignment]\r\n        if instance is None:\r\n            logger.error(\&quot;Failed to create instance\&quot;)\r\n            return None\r\n        attached_volumes: Iterable = instance.attached_volumes  # type: ignore[reportAssignmentType]  # noqa: F821\r\n        if len(attached_volumes) &gt; 0:  # type: ignore[reportArgType]  # noqa: WPS507\r\n            break\r\n        logger.info(f\&quot;Waiting for volume to attach to instance '{instance.name}'\&quot;)\r\n        sleep(2)\r\n\r\n    if instance:\r\n        logger.success(f\&quot;Created instance '{instance.name}'\&quot;)\r\n    else:\r\n        logger.error(\&quot;Failed to create instance\&quot;)\r\n    return instance\r\n\r\n\r\n@app.command()\r\ndef delete_instance(instance) -&gt; None:  # type: ignore[reportRedeclaration]  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Delete the specified instance.\r\n\r\n    Args:\r\n    ----\r\n    instance (openstack.compute.v2.server.Server): The instance to delete.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    instance: Server | None  # Hack to avoid type error\r\n    conn = OpenStackConnection.instance()\r\n    if isinstance(instance, str):\r\n        # Find the base instance\r\n        instance = conn.compute.find_server(instance)\r\n        if not instance:\r\n            logger.error(f\&quot;Instance '{instance}' not found\&quot;)\r\n            return\r\n\r\n    if not instance.name.startswith(\&quot;ic-\&quot;):\r\n        logger.warning(f\&quot;Instance '{instance.name}' is not a render node and cannot be deleted.\&quot;)\r\n        return\r\n    logger.info(f\&quot;Deleting instance '{instance.name}'\&quot;)\r\n    deleted_result = instance.delete(conn.compute)\r\n    if deleted_result:\r\n        logger.success(f\&quot;Deleted instance '{instance.name}'\&quot;)\r\n    else:\r\n        logger.error(f\&quot;Failed to delete instance '{instance.name}'\&quot;)\r\n\r\n\r\n@app.command()\r\ndef delete_all_stopped_instances() -&gt; list[Server]:\r\n    \&quot;\&quot;\&quot;Delete all stopped instances.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    logger.info(\&quot;Deleting all stopped instances\&quot;)\r\n    stopped_instances = conn.search_servers(filters={\&quot;status\&quot;: \&quot;SHUTOFF\&quot;}, bare=True)\r\n    stopped_instances_count = len(stopped_instances)\r\n    logger.info(f\&quot;Found {stopped_instances_count} stopped instances\&quot;)\r\n    stopped_instance: Server\r\n    for stopped_instance in stopped_instances:\r\n        if stopped_instance.status == \&quot;SHUTOFF\&quot;:\r\n            # attached_volumes: list[Volume] = conn.get_volume(instance.attached_volumes)  # noqa: ERA001\r\n            delete_instance(stopped_instance)\r\n            logger.info(f\&quot;Deleted instance '{stopped_instance.name}'\&quot;)  # Deleting the attached volumes\r\n            # for volume in attached_volumes:\r\n            #     logger.info(f\&quot;Deleting volume '{volume.name}'\&quot;)  # noqa: ERA001\r\n            #     logger.info(f\&quot;Delete on termination: {volume.delete_on_termination}\&quot;)  # noqa: ERA001\r\n            #     delete_volume(volume)  # noqa: ERA001\r\n    return stopped_instances\r\n\r\n\r\ndef find_error_instances() -&gt; list[Server]:\r\n    \&quot;\&quot;\&quot;Find all error instances.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    logger.info(\&quot;Finding all error instances\&quot;)\r\n    error_instances = conn.search_servers(filters={\&quot;status\&quot;: \&quot;ERROR\&quot;}, bare=True)\r\n    error_instances_count = len(error_instances)\r\n    logger.info(f\&quot;Found {error_instances_count} error instances\&quot;)\r\n    for instance in error_instances:\r\n        if instance.status == \&quot;ERROR\&quot;:\r\n            logger.info(f\&quot;Found instance '{instance.name}'\&quot;)\r\n    return error_instances\r\n\r\n\r\n@app.command()\r\ndef delete_all_error_instances(error_instances=None) -&gt; list[Server]:  # type: ignore[reportRedeclaration]  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Delete all instances that are in an error state.\r\n\r\n    This function iterates over all instances that are in an error state and deletes them.\r\n    If a list of error instances is provided, it will only delete those instances.\r\n    If no list is provided, it will find all instances in an error state and delete them.\r\n\r\n    Args:\r\n    ----\r\n        error_instances (list, optional): A list of instances in an error state to delete.\r\n                                           If None, the function will find all instances in an error state.\r\n\r\n    Returns:\r\n    -------\r\n        list: A list of instances that were in an error state and have been deleted.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    error_instances: list[Server]  # Hack to avoid type error\r\n    logger.info(\&quot;Deleting all error instances\&quot;)\r\n    if not error_instances:\r\n        error_instances = find_error_instances()\r\n    for instance in error_instances:\r\n        if instance.status == \&quot;ERROR\&quot;:\r\n            delete_instance(instance)\r\n            logger.info(f\&quot;Deleted instance '{instance.name}'\&quot;)\r\n    return error_instances\r\n\r\n\r\n@dataclass\r\nclass Instance:\r\n    \&quot;\&quot;\&quot;\r\n    A data class that represents an instance.\r\n\r\n    This class is used to store the name and status of an instance. It's a simple data holder\r\n    and doesn't contain any methods.\r\n\r\n    Attributes\r\n    ----------\r\n    name : str\r\n        The name of the instance.\r\n    status : str\r\n        The status of the instance.\r\n\r\n    \&quot;\&quot;\&quot;\r\n\r\n    name: str\r\n    status: str\r\n\r\n\r\ndef generate_instance_list(\r\n    gpu_model: str,\r\n    gpu_count: int = 1,\r\n    first_instance_number: int = 1,\r\n    last_instance_number: int = 99,\r\n) -&gt; list[Instance]:\r\n    \&quot;\&quot;\&quot;\r\n    Generate a list of instances with the specified parameters.\r\n\r\n    Returns\r\n    -------\r\n    list[NamedTuple]: A list of instances with the specified parameters.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    instances = []\r\n    for instance_number in range(first_instance_number, last_instance_number + 1):\r\n        instance_name = get_instance_name(gpu_model, gpu_count, instance_number)\r\n        instance = Instance(name=instance_name, status=\&quot;NONEXISTING\&quot;)\r\n        instances.append(instance)\r\n    return instances\r\n\r\n\r\nFIRST_INSTANCE_NUMBER = 0\r\nLAST_INSTANCE_NUMBER = 99\r\nlist_4090_instances = generate_instance_list(\&quot;4090\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_3080_instances = generate_instance_list(\&quot;3080\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_2080ti_instances = generate_instance_list(\&quot;2080Ti\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_3090_instances = generate_instance_list(\&quot;3090\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_5000_instances = generate_instance_list(\&quot;5000\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\n\r\n\r\ndef print_instance_statuses(instance_type: str, instances: list[Instance]) -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Print the statuses of instances in a visual format.\r\n\r\n    Parameters\r\n    ----------\r\n    instance_type : str\r\n        The type of the instances. This is printed at the start of the line.\r\n    instances : list[Instance]\r\n        The list of instances whose statuses are to be printed.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    print(f\&quot;{instance_type}:\&quot;, end=\&quot;\&quot;)  # noqa: T201\r\n    for index, instance in enumerate(instances):\r\n        if index % 10 == 0:\r\n            print(\&quot; \&quot;, end=\&quot;\&quot;)  # noqa: T201\r\n        status_symbols = {\r\n            \&quot;ACTIVE\&quot;: \&quot;â–ˆ\&quot;,\r\n            \&quot;ERROR\&quot;: \&quot;\\033[1m\\033[31mE\\033[0m\&quot;,\r\n            \&quot;SHUTOFF\&quot;: \&quot;S\&quot;,\r\n            \&quot;BUILD\&quot;: \&quot;B\&quot;,\r\n            \&quot;NONEXISTING\&quot;: \&quot;Â·\&quot;,\r\n        }\r\n        print(status_symbols.get(instance.status, \&quot;?\&quot;), end=\&quot;\&quot;)  # noqa: T201\r\n    print()  # noqa: T201\r\n\r\n\r\n@app.command()\r\ndef get_overview(server_list=None) -&gt; list[Server]:  # type: ignore[override]  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Retrieve an overview of all the instances in the OpenStack environment.\r\n\r\n    It categorizes the instances based on the flavor (type of instance) and updates the status of each instance.\r\n    The function also prints a visual representation of the instances' statuses.\r\n\r\n    Returns\r\n    -------\r\n    list[openstack.compute.v2.server.Server]: A list of all servers in the OpenStack environment.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    server_list: list[Server]  # Hack to avoid type error\r\n    servers = server_list or refresh_instance_list()\r\n    logger.info(\&quot;Overview of instances:\&quot;)\r\n    print(\&quot;     \&quot;, \&quot;0\&quot; * 10, \&quot;1\&quot; * 10, \&quot;2\&quot; * 10, \&quot;3\&quot; * 10, \&quot;4\&quot; * 10, \&quot;5\&quot; * 10, \&quot;6\&quot; * 10, \&quot;7\&quot; * 10, \&quot;8\&quot; * 10, \&quot;9\&quot; * 10)  # noqa: T201 WPS221\r\n    print(\&quot;      \&quot;, \&quot;0123456789 \&quot; * 10, sep=\&quot;\&quot;)  # noqa: T201\r\n    print_instance_statuses(\&quot;4090\&quot;, list_4090_instances)\r\n    print_instance_statuses(\&quot;3080\&quot;, list_3080_instances)\r\n    print_instance_statuses(\&quot;3090\&quot;, list_3090_instances)\r\n    print_instance_statuses(\&quot;5000\&quot;, list_5000_instances)\r\n    return servers\r\n\r\n\r\ndef refresh_instance_list() -&gt; list[Server]:\r\n    \&quot;\&quot;\&quot;\r\n    Refresh the list of instances in the OpenStack environment.\r\n\r\n    This function retrieves the OpenStack connection and lists all servers (instances).\r\n    It then iterates over each server and checks the flavor (type) of the server.\r\n    Depending on the flavor, it updates the corresponding list of instances with the server's information.\r\n\r\n    Returns\r\n    -------\r\n    list[Server]\r\n        A list of all servers in the OpenStack environment.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    logger.debug(\&quot;Loading servers list...\&quot;)\r\n    conn = OpenStackConnection.instance()\r\n    servers: list[Server] = conn.list_servers(bare=True)  # type: ignore[assignment]\r\n    for server in servers:\r\n        flavor: Flavor | None | Any = server.flavor\r\n        if not flavor:\r\n            continue\r\n        if flavor.name in {flavor_name_4090, flavor_name_4090_aux}:\r\n            update_list_of_instances(list_4090_instances, server)\r\n        elif flavor.name == flavor_name_3080:\r\n            update_list_of_instances(list_3080_instances, server)\r\n        elif flavor.name in {flavor_name_3090, flavor_name_3090_aux}:\r\n            update_list_of_instances(list_3090_instances, server)\r\n        elif flavor.name == flavor_name_5000:\r\n            update_list_of_instances(list_5000_instances, server)\r\n    return servers\r\n\r\n\r\ndef update_list_of_instances(instances: list[Instance], server: Server) -&gt; bool | None:\r\n    \&quot;\&quot;\&quot;\r\n    Update the status of instances in the provided list based on the server's status.\r\n\r\n    This function iterates over the provided list of instances and checks if the name of each instance matches\r\n    the name of the provided server. If a match is found, the status of the instance is updated to match the\r\n    status of the server.\r\n\r\n    Args:\r\n    ----\r\n        instances (list[Instance]): A list of instances whose status needs to be updated.\r\n        server (openstack.compute.v2.server.Server): The server whose status is used to update the instances.\r\n\r\n    Returns:\r\n    -------\r\n        bool: True if an instance's status was updated, otherwise None.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    for instance in instances:\r\n        logger.trace(f\&quot;Checking instance '{instance.name}'\&quot;)\r\n        logger.trace(f\&quot;Server name: '{server.name}'\&quot;)\r\n        if instance.name == server.name:\r\n            logger.trace(f\&quot;Updating instance '{server.name}'\&quot;)\r\n            instance.status = str(server.status)\r\n            return True\r\n    return None\r\n\r\n\r\ndef find_available_server_slots(instance_list: list[Instance]) -&gt; list[int]:\r\n    \&quot;\&quot;\&quot;\r\n    Find the available server slots in the provided instance list.\r\n\r\n    This function refreshes the instance list and returns a list of available server slots.\r\n    A server slot is considered available if the instance status is \&quot;NONEXISTING\&quot;\r\n    and the instance name does not end with \&quot;-00\&quot;.\r\n    The function returns the instance numbers of the available slots.\r\n\r\n    Args:\r\n    ----\r\n        instance_list (list[Instance]): A list of instances to check for available server slots.\r\n\r\n    Returns:\r\n    -------\r\n        list[int]: A list of available server slot numbers.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    refresh_instance_list()\r\n    return [\r\n        int(instance.name[-2:])  # The instance number from the name\r\n        for instance in instance_list\r\n        if instance.status == \&quot;NONEXISTING\&quot; and not instance.name.endswith(\&quot;-00\&quot;)\r\n    ]\r\n\r\n\r\n@functools.lru_cache\r\ndef get_local_networks() -&gt; tuple[Network, list[Network]] | None:\r\n    \&quot;\&quot;\&quot;\r\n    Retrieve the local network and gateway networks.\r\n\r\n    This function retrieves the local network by its name \&quot;NAS-LAN\&quot; and also calls the function get_gateway_networks()\r\n    to retrieve the gateway networks. Both the local network and gateway networks are returned.\r\n\r\n    Args:\r\n    ----\r\n        conn (openstack.connection.Connection): The OpenStack connection object used to interact with the OpenStack API.\r\n\r\n    Returns:\r\n    -------\r\n        tuple: A tuple containing the local network and the gateway networks.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    logger.info(\&quot;Getting local network\&quot;)\r\n    conn = OpenStackConnection.instance()\r\n    local_network: Network | None = conn.get_network(LAN_NAME)\r\n    if not local_network:\r\n        logger.error(f\&quot;Local network '{LAN_NAME}' not found\&quot;)\r\n        return None\r\n    gateway_networks = get_gateway_networks()\r\n    return local_network, gateway_networks\r\n\r\n\r\n@app.command()\r\ndef create_new_instances(gpu_model: str = \&quot;4090\&quot;, instance_count: int = 50) -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Create new instances based on the provided GPU model and instance count.\r\n\r\n    This function retrieves the OpenStack connection and checks the GPU model.\r\n    If the GPU model is either \&quot;4090\&quot; or \&quot;3090\&quot;, it sets the GPU count, flavor of choice, and instance list accordingly.\r\n    If the GPU model is not recognized, it logs an error and exits.\r\n\r\n\r\n    If any error instances are found during the creation process, it logs an error, deletes all error instances,\r\n    and breaks the loop.\r\n\r\n    Args:\r\n    ----\r\n        gpu_model (str): The model of the GPU. Either \&quot;4090\&quot; or \&quot;3090\&quot;.\r\n        instance_count (int): The number of instances to create.\r\n\r\n    Raises:\r\n    ------\r\n        openstack.exceptions.ResourceNotFound: If the flavor of choice is not found.\r\n        openstack.exceptions.ResourceTimeout: If a timeout occurs when creating an instance.\r\n        openstack.exceptions.SDKException: If any other error occurs when creating an instance.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    # Cloning the base volume into work nodes\r\n    conn = OpenStackConnection.instance()\r\n\r\n    if gpu_model == \&quot;4090\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_4090\r\n        instance_list = list_4090_instances\r\n        gpu_model = \&quot;4090\&quot;\r\n\r\n    elif gpu_model == \&quot;3090\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_3090\r\n        instance_list = list_3090_instances\r\n        gpu_model = \&quot;3090\&quot;\r\n\r\n    elif gpu_model == \&quot;3080\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_3080\r\n        instance_list = list_3080_instances\r\n        gpu_model = \&quot;3080\&quot;\r\n\r\n    elif gpu_model == \&quot;2080Ti\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_2080ti\r\n        instance_list = list_2080ti_instances\r\n        gpu_model = \&quot;2080Ti\&quot;\r\n\r\n    elif gpu_model == \&quot;A5000\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_5000\r\n        instance_list = list_5000_instances\r\n        gpu_model = \&quot;A5000\&quot;\r\n\r\n    else:\r\n        logger.error(f\&quot;GPU model '{gpu_model}' not found\&quot;)\r\n        sys.exit(1)\r\n\r\n    how_many_instances_to_create = instance_count\r\n\r\n    get_local_networks()\r\n    logger.info(f\&quot;Retrieving the flavor: {flavor_of_choice}\&quot;)\r\n    try:\r\n        flavor: Flavor | None = conn.get_flavor(name_or_id=flavor_of_choice)\r\n    except ResourceNotFound:\r\n        logger.error(f\&quot;Flavor '{flavor_of_choice}' not found. Aborting instance creation.\&quot;)\r\n        return\r\n    if not flavor:\r\n        logger.error(\&quot;Flavor lookup went wrong. OpenStack connection might be down.\&quot;)\r\n        return\r\n    logger.info(f\&quot;Found flavor '{flavor.name}'\&quot;)\r\n    available_server_slots = find_available_server_slots(instance_list=instance_list)[:how_many_instances_to_create]\r\n    logger.info(f\&quot;Creating {how_many_instances_to_create} instance(s) with number(s)\&quot; f\&quot; {available_server_slots}\&quot;)\r\n    try:\r\n        for i in available_server_slots:\r\n            create_instance(count_number=i, throwaway=True, flavor=flavor, gpu_model=gpu_model, gpu_count=gpu_count)\r\n            logger.info(f\&quot;Sleeping for {seconds_between_instance_creation} seconds\&quot;)\r\n            sleep(seconds_between_instance_creation)\r\n            error_instances = find_error_instances()\r\n            if error_instances:\r\n                logger.error(f\&quot;Error instances found: {error_instances}\&quot;)\r\n                delete_all_error_instances()\r\n                break\r\n            get_overview()\r\n\r\n    except ResourceTimeout as e:\r\n        logger.error(f\&quot;{e}\&quot;)\r\n    except SDKException as e:\r\n        logger.error(f\&quot;{e}\&quot;)\r\n        delete_all_error_instances()\r\n\r\n\r\n@app.command()\r\ndef create_base_instance(\r\n    gpu_model: str = \&quot;4090\&quot;,\r\n    gpu_count: int = 1,\r\n    flavor_of_choice: str = flavor_name_4090,\r\n) -&gt; Server | None:\r\n    \&quot;\&quot;\&quot;\r\n    Create a base instance with the specified parameters.\r\n\r\n    This function retrieves the OpenStack connection and the flavor of the instance to be created.\r\n    If the flavor is not found, it logs an error and returns.\r\n    If the flavor is found, it creates an instance with the specified parameters.\r\n\r\n    The parameters for the instance are:\r\n    - count_number: 0\r\n    - throwaway: False\r\n    - flavor: The flavor retrieved earlier\r\n    - gpu_model: The GPU model specified as an argument (default is \&quot;4090\&quot;)\r\n    - gpu_count: The number of GPUs specified as an argument (default is 1)\r\n    - volume_name: \&quot;rendernode - base\&quot;\r\n\r\n    Args:\r\n    ----\r\n        gpu_model (str, optional): The model of the GPU. Defaults to \&quot;4090\&quot;.\r\n        gpu_count (int, optional): The number of GPUs. Defaults to 1.\r\n        flavor_of_choice (str, optional): The flavor of the instance. Defaults to flavor_name_4090.\r\n\r\n    Returns:\r\n    -------\r\n        Server | None: The created instance if successful, None otherwise.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    # Get the OpenStack connection instance\r\n    conn = OpenStackConnection.instance()\r\n\r\n    # Get the flavor of the instance to be created\r\n    flavor: Flavor | None = conn.get_flavor(name_or_id=flavor_of_choice)\r\n\r\n    # If the flavor is not found, log an error and return\r\n    if not flavor:\r\n        logger.error(f\&quot;Flavor '{flavor_of_choice}' not found\&quot;)\r\n        return None\r\n\r\n    # If the flavor is found, create an instance with the specified parameters\r\n    return create_instance(\r\n        count_number=0,\r\n        throwaway=False,\r\n        flavor=flavor,\r\n        gpu_model=gpu_model,\r\n        gpu_count=gpu_count,\r\n        volume_name=\&quot;rendernode - base\&quot;,\r\n        wait_for_instance_creation_status=True,\r\n    )\r\n\r\n\r\n@app.command()\r\ndef delete_base_instance() -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Delete the base instance.\r\n\r\n    This function retrieves the OpenStack connection and finds the base instance by its name \&quot;ic-4090-x1-00\&quot;.\r\n    If the base instance is found, it is deleted. If not, a warning is logged.\r\n\r\n    Raises\r\n    ------\r\n        openstack.exceptions.ResourceNotFound: If the base instance is not found.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    # Get the OpenStack connection instance\r\n    conn = OpenStackConnection.instance()\r\n\r\n    # Define the name of the base instance\r\n    instance_name = \&quot;ic-4090-x1-00\&quot;\r\n\r\n    # Find the base instance\r\n    server = conn.compute.find_server(instance_name)\r\n\r\n    # If the base instance is found, delete it\r\n    if server:\r\n        delete_instance(server)\r\n    # If the base instance is not found, log a warning\r\n    else:\r\n        logger.warning(f\&quot;Server {instance_name} is not found\&quot;)\r\n\r\n\r\n@app.command()\r\ndef list_volumes() -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    List all volumes in the OpenStack environment.\r\n\r\n    This function retrieves the OpenStack connection and lists all volumes.\r\n    For each volume, it logs the volume's name and status.\r\n\r\n    The function does not return anything as it's intended for logging purposes.\r\n    \&quot;\&quot;\&quot;\r\n    # Get the OpenStack connection instance\r\n    conn = OpenStackConnection.instance()\r\n\r\n    # List all volumes\r\n    all_volumes = conn.list_volumes()\r\n\r\n    # For each volume, log its name and status\r\n    for volume in all_volumes:\r\n        v = volume.to_dict()\r\n        logger.info(f\&quot;{v['name']:&lt;20}: {v['status']:&lt;20} ID:{v['id']}\&quot;)\r\n\r\n\r\n@app.command()\r\ndef version() -&gt; None:\r\n    \&quot;\&quot;\&quot;Print the current version of the application.\&quot;\&quot;\&quot;\r\n    typer.echo(__version__)\r\n\r\n\r\n@app.command()\r\ndef loop_clean_instances(timeout: int = 15) -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Continuously cleans up stopped and error instances.\r\n\r\n    This function enters an infinite loop where it continuously deletes all stopped and error instances.\r\n    After each cleanup, the function sleeps for a specified timeout period before repeating the process.\r\n\r\n    Args:\r\n    ----\r\n        timeout (int, optional): The number of seconds to sleep after each cleanup. Defaults to 10.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    logger.info(\&quot;Press 'Esc' to exit the loop\&quot;)\r\n    while True:  # noqa: WPS457\r\n        delete_all_stopped_instances()\r\n        delete_all_error_instances()\r\n        with Progress(\r\n            TextColumn(\&quot;[progress.description]{task.description}\&quot;),\r\n            BarColumn(complete_style=\&quot;cyan\&quot;),\r\n            TimeRemainingColumn(),\r\n            transient=True,\r\n        ) as progress:\r\n            timer = progress.add_task(\&quot;[cyan]Sleeping\&quot;, total=timeout)\r\n            timer_update_delay = 0.02\r\n            while not progress.finished:\r\n                progress.update(timer, advance=timer_update_delay)\r\n                sleep(timer_update_delay)\r\n                if keyboard.is_pressed(\&quot;esc\&quot;):\r\n                    logger.success(\&quot;Escape key pressed, exiting...\&quot;)\r\n                    return\r\n\r\n\r\n@app.command()\r\ndef check_if_4090_is_available():\r\n    \&quot;\&quot;\&quot;Check if there are available slots for 4090 instances.\&quot;\&quot;\&quot;\r\n    from al_ic import check_avaliability\r\n\r\n    check_avaliability.check_if_4090_is_available()\r\n\r\n\r\n@app.command()\r\ndef main() -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Old UI flow. Retained for a while in case new UI breaks.\r\n\r\n    This function provides a command-line interface to perform various operations on instances such as:\r\n    - Deleting all stopped instances\r\n    - Deleting all error instances\r\n    - Creating new instances\r\n    - Refreshing the overview of instances\r\n    - Creating a base instance for updating credentials\r\n    - Deleting the base instance after updating credentials\r\n    - Deleting all throwaway volumes\r\n    - Listing all volumes\r\n\r\n    Each operation is confirmed by the user before it is performed.\r\n    \&quot;\&quot;\&quot;\r\n    if typer.confirm(\&quot;Delete all stopped instances?\&quot;):\r\n        delete_all_stopped_instances()\r\n    if typer.confirm(\&quot;Delete all error instances?\&quot;):\r\n        delete_all_error_instances()\r\n    if typer.confirm(\&quot;Create new instances?\&quot;):\r\n        instance_count = 50\r\n        create_new_instances(\&quot;4090\&quot;, instance_count)\r\n    while True:\r\n        get_overview()\r\n        if not typer.confirm(\&quot;Refresh instances?\&quot;):\r\n            break\r\n    if typer.confirm(\&quot;Create base instance for updating credentials\&quot;):\r\n        create_base_instance()\r\n    if typer.confirm(\&quot;Delete base instance after updating credentials\&quot;):\r\n        delete_base_instance()\r\n    if typer.confirm(\&quot;Delete all throwaway volumes?\&quot;):\r\n        delete_throwaway_volumes()\r\n    if typer.confirm(\&quot;list all volumes?\&quot;):\r\n        list_volumes()\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\__init__.py\nFile Content:\n```py\r\n\&quot;\&quot;\&quot;Amber Light Immers.Cloud manager.\&quot;\&quot;\&quot;\r\n# SPDX-FileCopyrightText: 2024-present Mike Talalaevskiy &lt;mital@amber-light.de&gt;\r\n#\r\n# SPDX-License-Identifier: MIT\r\n\r\nfrom al_ic import main\r\nfrom al_ic.__about__ import __version__\r\n\r\n__all__ = [\&quot;main\&quot;, \&quot;__version__\&quot;]\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\__main__.py\nFile Content:\n```py\r\n\&quot;\&quot;\&quot;Entry point for the CLI application.\&quot;\&quot;\&quot;\r\n\r\nfrom al_ic.main import app\r\n\r\nif __name__ == \&quot;__main__\&quot;:\r\n    app()\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\__about__.py\nFile Content:\n```py\r\n# SPDX-FileCopyrightText: 2024-present Mike Talalaevskiy &lt;mital@amber-light.de&gt;\r\n#\r\n# SPDX-License-Identifier: MIT\r\n__version__ = \&quot;0.2.5\&quot;\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\check_avaliability.py\nFile Content:\n```py\r\nfrom pathlib import Path\r\nfrom time import sleep\r\n\r\nimport pygame\r\nimport requests\r\nfrom loguru import logger\r\nfrom rich.progress import BarColumn, Progress, TextColumn, TimeRemainingColumn\r\n\r\n\r\ndef check_flavor_availability():\r\n    url = \&quot;http://immers.cloud/apiv2/flavor/is-available/\&quot;\r\n    params = {\&quot;id\&quot;: \&quot;1031\&quot;, \&quot;destinationType\&quot;: \&quot;volume\&quot;}\r\n    headers = {\r\n        \&quot;Accept\&quot;: \&quot;application/json\&quot;,\r\n        \&quot;access-token\&quot;: \&quot;JbegAKn3tkNkfkab3iefkNkaefb\&quot;,\r\n    }\r\n\r\n    try:\r\n        response = requests.get(url, headers=headers, params=params)\r\n        response.raise_for_status()  # Raises an HTTPError for bad responses\r\n        return response.text\r\n    except requests.RequestException as e:\r\n        logger.error(f\&quot;An error occurred: {e}\&quot;)\r\n        return None\r\n\r\n\r\ndef beep_if_available(content):\r\n    if \&quot;1\&quot; in content:\r\n        try:\r\n            logger.success(\&quot;Flavor is available!\&quot;)\r\n            pygame.mixer.init()\r\n            pygame.mixer.music.load(\r\n                Path(__file__).parent.resolve() / \&quot;Windows XP Feed Discovered.wav\&quot;,\r\n            )  # Ensure you have a beep.mp3 file\r\n            pygame.mixer.music.play()\r\n            while pygame.mixer.music.get_busy():  # Wait for the sound to finish playing\r\n                pygame.time.Clock().tick(10)\r\n\r\n        except Exception as e:\r\n            logger.error(f\&quot;Failed to play sound: {e}\&quot;)\r\n    else:\r\n        logger.info(\&quot;Flavor is not available\&quot;)\r\n\r\n\r\ndef check_if_4090_is_available():\r\n    while True:  # noqa: WPS457\r\n        logger.info(\&quot;Checking flavor availability...\&quot;)\r\n        content = check_flavor_availability()\r\n        if content:\r\n            beep_if_available(content)\r\n        timeout = 10\r\n\r\n        with Progress(\r\n            TextColumn(\&quot;[progress.description]{task.description}\&quot;),\r\n            BarColumn(complete_style=\&quot;cyan\&quot;),\r\n            TimeRemainingColumn(),\r\n            transient=True,\r\n        ) as progress:\r\n            timer = progress.add_task(\&quot;[cyan]Sleeping\&quot;, total=timeout)\r\n            timer_update_delay = 0.02\r\n            while not progress.finished:\r\n                progress.update(timer, advance=timer_update_delay)\r\n                sleep(timer_update_delay)\r\n                # if keyboard.is_pressed(\&quot;esc\&quot;):\r\n                #     logger.success(\&quot;Escape key pressed, exiting...\&quot;)\r\n                #     return\r\n\r\n\r\nif __name__ == \&quot;__main__\&quot;:\r\n    check_if_4090_is_available()\r\n```\n\nQuestion: What can you tell me about this project. What issues and technical debt do you see?&quot;,&quot;id&quot;:&quot;138c6745-2228-43a1-a03e-11baed317b2f&quot;,&quot;response&quot;:&quot;This project is a command-line interface (CLI) application for managing OpenStack resources, specifically designed to handle instances and volumes related to GPU models. It uses several external libraries such as `typer` for CLI commands, `loguru` for logging, `openstack` SDK for interacting with OpenStack, and `rich` for progress bars.\n\n### Issues and Technical Debt\n\n1. **Code Duplication**:\n   - There are multiple places where similar logic is repeated, such as in the `create_instance` and `create_new_instances` functions. This can be refactored to reduce redundancy.\n\n2. **Error Handling**:\n   - Error handling is present but could be more robust. For example, in `create_new_instances`, if an error occurs, it logs the error but does not provide a mechanism to retry or handle specific types of errors differently.\n\n3. **Hardcoded Values**:\n   - Several hardcoded values like `flavor_name_4090`, `LAN_NAME`, and `seconds_between_instance_creation` are scattered throughout the code. These should be moved to a configuration file or environment variables.\n\n4. **Logging**:\n   - While `loguru` is used for logging, there are some inconsistencies in log levels and messages. For instance, some critical operations use `logger.info` instead of `logger.error` or `logger.warning`.\n\n5. **Type Annotations**:\n   - Type annotations are used inconsistently. Some functions have type hints, while others do not. Consistent use of type hints would improve code readability and maintainability.\n\n6. **Function Complexity**:\n   - Some functions, like `create_instance` and `create_new_instances`, are quite long and complex. Breaking them down into smaller, more manageable functions would improve readability and maintainability.\n\n7. **Documentation**:\n   - While docstrings are present, they could be more detailed, especially for complex functions. Additionally, there is no overall project documentation or README file explaining how to set up and run the project.\n\n8. **Testing**:\n   - There is no indication of unit tests or integration tests. Adding tests would help ensure the reliability and stability of the codebase.\n\n9. **Dependency Management**:\n   - The project relies on several external libraries, but there is no mention of a `requirements.txt` or `Pipfile` for managing these dependencies.\n\n10. **Singleton Pattern**:\n    - The `OpenStackConnection` class uses a singleton pattern, which is generally fine, but it could be improved by using thread-safe mechanisms to ensure it works correctly in multi-threaded environments.\n\n11. **Magic Numbers and Strings**:\n    - The code contains magic numbers and strings, such as status symbols in `print_instance_statuses`. These should be defined as constants to improve readability and maintainability.\n\n12. **Unused Imports and Variables**:\n    - There are some unused imports and variables, such as `sys` and `functools.lru_cache` in `main.py`. These should be removed to clean up the code.\n\n### Recommendations\n\n- **Refactor Code**: Break down large functions into smaller, reusable functions. Remove duplicate code.\n- **Improve Error Handling**: Implement more robust error handling and consider adding retry mechanisms.\n- **Configuration Management**: Move hardcoded values to a configuration file or environment variables.\n- **Consistent Logging**: Standardize logging levels and messages.\n- **Type Annotations**: Use type annotations consistently across the codebase.\n- **Documentation**: Add detailed docstrings and a README file.\n- **Testing**: Implement unit tests and integration tests.\n- **Dependency Management**: Add a `requirements.txt` or `Pipfile`.\n- **Singleton Pattern**: Ensure the singleton pattern is thread-safe.\n- **Constants**: Define magic numbers and strings as constants.\n- **Clean Up**&quot;,&quot;userMessage&quot;:&quot;What can you tell me about this project. What issues and technical debt do you see?&quot;,&quot;serpResults&quot;:null,&quot;referencedFilePaths&quot;:[&quot;P:\\Python\\al-ic\\src\\al_ic\\main.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\__init__.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\__main__.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\__about__.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\check_avaliability.py&quot;],&quot;imageFilePath&quot;:null}],&quot;clientCode&quot;:&quot;chat.completion&quot;,&quot;model&quot;:&quot;gpt-4o&quot;,&quot;createdOn&quot;:[2024,5,19,13,30,49,504011500],&quot;updatedOn&quot;:[2024,5,19,13,33,59,368606500],&quot;discardTokenLimit&quot;:false},{&quot;id&quot;:&quot;f5cdfe7c-d141-4d89-a680-dd088f185b4d&quot;,&quot;messages&quot;:[],&quot;clientCode&quot;:&quot;chat.completion&quot;,&quot;model&quot;:&quot;gpt-4o&quot;,&quot;createdOn&quot;:[2024,5,19,13,37,34,805638500],&quot;updatedOn&quot;:[2024,5,19,13,37,34,805638500],&quot;discardTokenLimit&quot;:false}]}}" />
    <option name="currentConversation" value="{&quot;id&quot;:&quot;2f8c1247-756c-40f8-8199-6230bb54ea19&quot;,&quot;messages&quot;:[{&quot;prompt&quot;:&quot;Use the following context to answer question at the end:\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\main.py\nFile Content:\n```py\r\n\&quot;\&quot;\&quot;Main module for the al-ic package. Everything happens here.\&quot;\&quot;\&quot;\r\n\r\nimport enum  # noqa: I001\r\nimport functools\r\nimport sys\r\nfrom dataclasses import dataclass\r\nfrom time import sleep\r\nfrom typing import Any\r\n\r\nimport keyboard  # type: ignore[reportMissingImports]\r\nimport typer  # type: ignore[reportMissingImports]\r\nfrom loguru import logger  # type: ignore[reportMissingImports]\r\nfrom openstack import connect, enable_logging\r\nfrom openstack.block_storage.v3.volume import Volume\r\nfrom openstack.compute.v2.flavor import Flavor\r\nfrom openstack.compute.v2.server import Server\r\nfrom openstack.connection import Connection\r\nfrom openstack.exceptions import ResourceNotFound, ResourceTimeout, SDKException\r\nfrom openstack.network.v2.network import Network\r\nfrom rich.progress import BarColumn, Progress, TextColumn, TimeRemainingColumn  # type: ignore[reportMissingImports]\r\n\r\nfrom al_ic.__about__ import __version__\r\n\r\nnon_deletable_volumes = {\&quot;migrating\&quot;, \&quot;attached\&quot;}\r\n\r\ndeletable_volumes = {\r\n    \&quot;available\&quot;,\r\n    \&quot;error\&quot;,\r\n    \&quot;error_restoring\&quot;,\r\n    \&quot;error_extending\&quot;,\r\n    \&quot;error_managing\&quot;,\r\n}\r\n\r\nLAN_NAME = \&quot;NAS-LAN\&quot;\r\n\r\n# Initialize and turn on debug logging\r\nenable_logging(debug=False, http_debug=False)\r\n\r\napp = typer.Typer()\r\n\r\n\r\nclass OpenStackConnection:\r\n    \&quot;\&quot;\&quot;\r\n    A class to manage a connection to OpenStack.\r\n\r\n    This class is a singleton, meaning it will only ever create one instance of the OpenStack connection.\r\n    This is useful when you want to make sure that only one connection is made to the OpenStack cloud in your\r\n    application.\r\n\r\n    Attributes\r\n    ----------\r\n        _instance (Connection|None): The single instance of the OpenStack connection.\r\n                                     It's initially None and gets assigned when get_instance() is called for the\r\n                                     first time.\r\n\r\n    Methods\r\n    -------\r\n        get_instance() -&gt; Connection: Returns the single instance of the OpenStack connection.\r\n                                      If it doesn't exist, it creates one.\r\n\r\n    \&quot;\&quot;\&quot;\r\n\r\n    _instance: Connection | None = None\r\n\r\n    @classmethod\r\n    def instance(cls) -&gt; Connection:\r\n        \&quot;\&quot;\&quot;\r\n        Return the single instance of the OpenStack connection.\r\n\r\n        If the connection instance doesn't exist, it creates one by connecting to the OpenStack cloud.\r\n        It also logs the connection process.\r\n\r\n        Returns\r\n        -------\r\n            Connection: The single instance of the OpenStack connection.\r\n\r\n        \&quot;\&quot;\&quot;\r\n        if cls._instance is None:\r\n            logger.info(\&quot;Connecting to OpenStack...\&quot;)\r\n            cls._instance = connect(cloud=\&quot;openstack\&quot;)\r\n            instance_name = cls._instance.name\r\n            logger.info(f\&quot;Connected to OpenStack: {instance_name}\&quot;)\r\n        return cls._instance\r\n\r\n\r\n# A list of volume names that are protected and should not be deleted.\r\n# These volumes are critical for the operation of the application and deleting them could cause issues.\r\nprotected_volumes = [\r\n    \&quot;rendernode - base\&quot;,\r\n    \&quot;rendernode - base backup\&quot;,\r\n    \&quot;juicefs-metadata-02\&quot;,\r\n    \&quot;juicefs-metadata-01\&quot;,\r\n    \&quot;s3-westcall-gateway\&quot;,\r\n    \&quot;s3-mgts-gateway\&quot;,\r\n    \&quot;s3-inetcom-gateway\&quot;,\r\n    \&quot;ic-4090-x1-00-volume\&quot;,\r\n]\r\n\r\n\r\nclass Providers(enum.StrEnum):\r\n    \&quot;\&quot;\&quot;\r\n    Enum for different providers.\r\n\r\n    This enum defines different providers such as AVANTEL, INETCOM, MGTS, and WESTCALL.\r\n    \&quot;\&quot;\&quot;\r\n\r\n    avantel = \&quot;avantel\&quot;\r\n    inetcom = \&quot;inetcom\&quot;\r\n    mgts = \&quot;mgts\&quot;\r\n    westcall = \&quot;westcall\&quot;\r\n\r\n\r\nseconds_between_instance_creation = 20\r\n\r\n\r\ndef get_gateway_networks() -&gt; list[Network]:\r\n    \&quot;\&quot;\&quot;\r\n    Retrieve gateway networks.\r\n\r\n    This function retrieves gateway networks by listing all networks and filtering out those\r\n    that do not meet a certain condition.\r\n\r\n    Returns\r\n    -------\r\n        list: A list of network objects that meet the specified condition.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n\r\n    logger.info(\&quot;Getting gateway networks\&quot;)\r\n    all_nets = conn.list_networks()\r\n    return [net for net in all_nets if str(net.name).lower() in Providers]\r\n\r\n\r\ndef get_instance_name(gpu_model: str, gpu_count: int | str, count_number: int) -&gt; str:\r\n    \&quot;\&quot;\&quot;\r\n    Return a formatted instance name.\r\n\r\n    Example: ic-4090-x1-00.\r\n    \&quot;\&quot;\&quot;\r\n    return f\&quot;ic-{gpu_model}-x{gpu_count}-{count_number:02d}\&quot;\r\n\r\n\r\n# TODO(Mike): Precache the flavors instead of getting them on the fly\r\nflavor_name_4090 = \&quot;rtx4090-1.16.96.160\&quot;\r\nflavor_name_4090_aux = \&quot;rtx4090-1.16.64.160\&quot;\r\n\r\nflavor_name_3090 = \&quot;rtx3090-1.16.96.160\&quot;\r\nflavor_name_3090_aux = \&quot;rtx3090-1.16.64.160\&quot;\r\n\r\nflavor_name_2080ti = \&quot;rtx2080ti-1.16.64.160\&quot;\r\n\r\nflavor_name_3080 = \&quot;rtx3080-1.16.64.160\&quot;\r\n\r\nflavor_name_5000 = \&quot;rtxa5000-2.16.128.160.nvlink\&quot;\r\n\r\ndefault_flavor_name = flavor_name_4090\r\n\r\ndefault_name = get_instance_name(\&quot;4090\&quot;, \&quot;1\&quot;, 0)\r\nbase_volume_name = \&quot;rendernode - base\&quot;\r\n\r\n\r\ndef get_base_volume() -&gt; Volume:\r\n    \&quot;\&quot;\&quot;\r\n    Find the base volume by name and checks if it's in use.\r\n\r\n    Returns\r\n    -------\r\n    openstack.block_storage.v3.volume.Volume: The base volume.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn: Connection = OpenStackConnection.instance()\r\n    base_volume: Volume = conn.volume.find_volume(base_volume_name)  # type: ignore[assignment] # Find a volume by name\r\n    base_volume_in_use = bool(len(base_volume.attachments))  # type: ignore[assignment]\r\n    logger.info(f\&quot;Base volume in use: {base_volume_in_use}\&quot;)\r\n    return base_volume\r\n\r\n\r\ndef create_volume_name_for_base_clone(gpu_model: str, gpu_count: int | str, count_number: int, throwaway: bool) -&gt; str:  # noqa: FBT001\r\n    \&quot;\&quot;\&quot;\r\n    Create a volume name for a base clone.\r\n\r\n    This function generates a volume name for a base clone based on the GPU model, GPU count, count number, and\r\n    whether the volume is a throwaway volume. The volume name is generated by appending the GPU model, GPU count,\r\n    and count number to the string \&quot;ic-\&quot;, and then appending a throwaway suffix (\&quot;-throwaway\&quot;) if the volume is\r\n    a throwaway volume.\r\n\r\n    Parameters\r\n    ----------\r\n    gpu_model : str\r\n        The model of the GPU.\r\n    gpu_count : int\r\n        The number of GPUs.\r\n    count_number : int\r\n        The count number of the instance.\r\n    throwaway : bool\r\n        Whether the volume is a throwaway volume.\r\n\r\n    Returns\r\n    -------\r\n    str\r\n        The generated volume name for the base clone.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    throwaway_suffix = \&quot;-throwaway\&quot; if throwaway else \&quot;\&quot;\r\n    instance_name = get_instance_name(gpu_model, gpu_count, count_number)\r\n    return f\&quot;{instance_name}{throwaway_suffix}-volume\&quot;\r\n\r\n\r\n@app.command()\r\ndef clone_base_volume(\r\n    gpu_model: str = \&quot;4090\&quot;,\r\n    gpu_count: int = 1,\r\n    count_number: int = 1,\r\n    *,\r\n    throwaway: bool = False,\r\n) -&gt; Volume | None:\r\n    \&quot;\&quot;\&quot;\r\n    Clones the base volume and returns the new volume.\r\n\r\n    Returns\r\n    -------\r\n    openstack.block_storage.v3.volume.Volume: The cloned volume.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    cloned_volume_name = create_volume_name_for_base_clone(gpu_model, gpu_count, count_number, throwaway=throwaway)\r\n    logger.info(f\&quot;Cloning base volume to '{cloned_volume_name}'\&quot;)\r\n    cloned_volume: Volume = Volume(connection=conn, name=cloned_volume_name, source_volume_id=get_base_volume().id)\r\n    cloned_volume.create(conn.volume)\r\n    while cloned_volume.status != \&quot;available\&quot;:\r\n        logger.info(f\&quot;Volume status: {cloned_volume.status}\&quot;)\r\n        possible_volume = conn.get_volume(cloned_volume.id)\r\n        if isinstance(possible_volume, Volume):\r\n            cloned_volume = possible_volume\r\n        else:\r\n            logger.error(f\&quot;Volume '{cloned_volume_name}' not found\&quot;)\r\n            return None\r\n        sleep(2)\r\n    logger.success(f\&quot;Volume status: {cloned_volume.status}\&quot;)\r\n    return cloned_volume\r\n\r\n\r\n@app.command()\r\ndef delete_volume(volume) -&gt; None | Volume:  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Delete the specified volume.\r\n\r\n    Args:\r\n    ----\r\n    volume (openstack.block_storage.v3.volume.Volume): The volume to delete.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    if isinstance(volume, str):\r\n        requested_volume = volume\r\n        volume = Volume.find(conn.volume, name_or_id=volume)\r\n        if not volume:\r\n            logger.error(f\&quot;Volume '{requested_volume}' is not found\&quot;)\r\n            return None\r\n    if isinstance(volume, Volume):\r\n        if volume.name in protected_volumes:\r\n            logger.warning(f\&quot;Volume '{volume.name}' is protected and cannot be deleted.\&quot;)\r\n            return None\r\n        return volume.delete(conn.volume)\r\n    return None\r\n\r\n\r\n@app.command()\r\ndef delete_throwaway_volumes(status: str = \&quot;available\&quot;) -&gt; None:\r\n    \&quot;\&quot;\&quot;Delete all throwaway volumes.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    logger.info(f\&quot;Deleting all throwaway volumes with status '{status}'\&quot;)\r\n    all_volumes = conn.list_volumes()\r\n    for volume in all_volumes:\r\n        if \&quot;-throwaway\&quot; in str(volume.name):\r\n            if volume.status in deletable_volumes and volume.status not in non_deletable_volumes:\r\n                delete_volume(volume)\r\n                logger.info(f\&quot;Deleted volume '{volume.name}'\&quot;)\r\n            else:\r\n                logger.warning(f\&quot;Volume '{volume.name}' has status '{volume.status}' and cannot be deleted.\&quot;)\r\n\r\n\r\ndef create_instance(\r\n    flavor: Flavor,\r\n    volume_name: str = \&quot;\&quot;,\r\n    gpu_model: str = \&quot;4090\&quot;,\r\n    gpu_count: int = 1,\r\n    count_number: int = 0,\r\n    *,\r\n    use_existing_volume: bool = True,\r\n    throwaway: bool = False,\r\n    wait_for_instance_creation_status: bool = False,\r\n) -&gt; Server | None:\r\n    \&quot;\&quot;\&quot;Create an instance with the default flavor and image.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    volume_auto_removal_condition = throwaway\r\n    if volume_auto_removal_condition:\r\n        logger.warning(\&quot;Volume will be automatically removed after instance termination\&quot;)\r\n\r\n    message_prefix = \&quot;Start of creating instance for \&quot;\r\n    instance_details = f\&quot;ic-{gpu_model}x{gpu_count}-{count_number:02d}\&quot;\r\n    logger.info(f\&quot;{message_prefix}{instance_details}\&quot;)\r\n\r\n    logger.info(f\&quot;Using flavor '{flavor.name}'\&quot;)\r\n\r\n    if not volume_name and use_existing_volume:\r\n        volume_name = create_volume_name_for_base_clone(gpu_model, gpu_count, count_number, throwaway)\r\n\r\n    # Abort if the volume is protected\r\n    if volume_name in protected_volumes and volume_auto_removal_condition:\r\n        logger.error(f\&quot;Volume '{volume_name}' is protected. Aborting instance creation.\&quot;)\r\n        return None\r\n\r\n    # Attempt to find the volume if a name is specified or determined\r\n    if volume_name:\r\n        logger.info(f\&quot;Looking for volume '{volume_name}'\&quot;)\r\n        volume = conn.volume.find_volume(volume_name)  # type: ignore[reportAttributeAccessIssue]\r\n        if volume:\r\n            logger.info(f\&quot;Found volume '{volume_name}'\&quot;)\r\n        else:\r\n            logger.warning(f\&quot;Volume '{volume_name}' not found\&quot;)\r\n    else:\r\n        volume = None\r\n\r\n    # If no volume is found or volume_name wasn't set, create a new one\r\n    if not volume_name or not volume:\r\n        volume_name = volume_name or create_volume_name_for_base_clone(\r\n            gpu_model,\r\n            gpu_count,\r\n            count_number,\r\n            throwaway=throwaway,\r\n        )\r\n        logger.info(f\&quot;Creating new volume '{volume_name}'\&quot;)\r\n        volume = clone_base_volume(gpu_model, gpu_count, count_number, throwaway=throwaway)\r\n    if not volume:\r\n        logger.error(f\&quot;Failed to create volume '{volume_name}'\&quot;)\r\n        return None\r\n\r\n    if volume.status != \&quot;available\&quot;:\r\n        logger.error(f\&quot;Volume '{volume_name}' is not available. Aborting instance creation.\&quot;)\r\n        return None\r\n\r\n    networks = get_local_networks()\r\n    if not networks:\r\n        logger.error(\&quot;Local network not found. Aborting instance creation.\&quot;)\r\n        return None\r\n    (local_network, gateway_networks) = networks\r\n\r\n    message_prefix = \&quot;Requesting an node instance \&quot;\r\n    instance_details = f\&quot;{gpu_model}x{gpu_count}-{count_number:02d}\&quot;\r\n    logger.info(f\&quot;{message_prefix}{instance_details}with volume '{volume.name}'\&quot;)\r\n    instance: Server = conn.create_server(\r\n        name=get_instance_name(gpu_model, gpu_count, count_number),\r\n        description=f\&quot;Render node for {gpu_model}x{gpu_count}\&quot;,\r\n        flavor=flavor,\r\n        boot_volume=volume,\r\n        network=[local_network, gateway_networks[0]],\r\n        terminate_volume=volume_auto_removal_condition,\r\n        wait=wait_for_instance_creation_status,\r\n        timeout=60 * 5,\r\n    )\r\n\r\n    while True:\r\n        instance: Server = conn.get_server(instance.id)  # type: ignore[assignment]\r\n        if instance is None:\r\n            logger.error(\&quot;Failed to create instance\&quot;)\r\n            return None\r\n        attached_volumes: Iterable = instance.attached_volumes  # type: ignore[reportAssignmentType]  # noqa: F821\r\n        if len(attached_volumes) &gt; 0:  # type: ignore[reportArgType]  # noqa: WPS507\r\n            break\r\n        logger.info(f\&quot;Waiting for volume to attach to instance '{instance.name}'\&quot;)\r\n        sleep(2)\r\n\r\n    if instance:\r\n        logger.success(f\&quot;Created instance '{instance.name}'\&quot;)\r\n    else:\r\n        logger.error(\&quot;Failed to create instance\&quot;)\r\n    return instance\r\n\r\n\r\n@app.command()\r\ndef delete_instance(instance) -&gt; None:  # type: ignore[reportRedeclaration]  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Delete the specified instance.\r\n\r\n    Args:\r\n    ----\r\n    instance (openstack.compute.v2.server.Server): The instance to delete.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    instance: Server | None  # Hack to avoid type error\r\n    conn = OpenStackConnection.instance()\r\n    if isinstance(instance, str):\r\n        # Find the base instance\r\n        instance = conn.compute.find_server(instance)\r\n        if not instance:\r\n            logger.error(f\&quot;Instance '{instance}' not found\&quot;)\r\n            return\r\n\r\n    if not instance.name.startswith(\&quot;ic-\&quot;):\r\n        logger.warning(f\&quot;Instance '{instance.name}' is not a render node and cannot be deleted.\&quot;)\r\n        return\r\n    logger.info(f\&quot;Deleting instance '{instance.name}'\&quot;)\r\n    deleted_result = instance.delete(conn.compute)\r\n    if deleted_result:\r\n        logger.success(f\&quot;Deleted instance '{instance.name}'\&quot;)\r\n    else:\r\n        logger.error(f\&quot;Failed to delete instance '{instance.name}'\&quot;)\r\n\r\n\r\n@app.command()\r\ndef delete_all_stopped_instances() -&gt; list[Server]:\r\n    \&quot;\&quot;\&quot;Delete all stopped instances.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    logger.info(\&quot;Deleting all stopped instances\&quot;)\r\n    stopped_instances = conn.search_servers(filters={\&quot;status\&quot;: \&quot;SHUTOFF\&quot;}, bare=True)\r\n    stopped_instances_count = len(stopped_instances)\r\n    logger.info(f\&quot;Found {stopped_instances_count} stopped instances\&quot;)\r\n    stopped_instance: Server\r\n    for stopped_instance in stopped_instances:\r\n        if stopped_instance.status == \&quot;SHUTOFF\&quot;:\r\n            # attached_volumes: list[Volume] = conn.get_volume(instance.attached_volumes)  # noqa: ERA001\r\n            delete_instance(stopped_instance)\r\n            logger.info(f\&quot;Deleted instance '{stopped_instance.name}'\&quot;)  # Deleting the attached volumes\r\n            # for volume in attached_volumes:\r\n            #     logger.info(f\&quot;Deleting volume '{volume.name}'\&quot;)  # noqa: ERA001\r\n            #     logger.info(f\&quot;Delete on termination: {volume.delete_on_termination}\&quot;)  # noqa: ERA001\r\n            #     delete_volume(volume)  # noqa: ERA001\r\n    return stopped_instances\r\n\r\n\r\ndef find_error_instances() -&gt; list[Server]:\r\n    \&quot;\&quot;\&quot;Find all error instances.\&quot;\&quot;\&quot;\r\n    conn = OpenStackConnection.instance()\r\n    logger.info(\&quot;Finding all error instances\&quot;)\r\n    error_instances = conn.search_servers(filters={\&quot;status\&quot;: \&quot;ERROR\&quot;}, bare=True)\r\n    error_instances_count = len(error_instances)\r\n    logger.info(f\&quot;Found {error_instances_count} error instances\&quot;)\r\n    for instance in error_instances:\r\n        if instance.status == \&quot;ERROR\&quot;:\r\n            logger.info(f\&quot;Found instance '{instance.name}'\&quot;)\r\n    return error_instances\r\n\r\n\r\n@app.command()\r\ndef delete_all_error_instances(error_instances=None) -&gt; list[Server]:  # type: ignore[reportRedeclaration]  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Delete all instances that are in an error state.\r\n\r\n    This function iterates over all instances that are in an error state and deletes them.\r\n    If a list of error instances is provided, it will only delete those instances.\r\n    If no list is provided, it will find all instances in an error state and delete them.\r\n\r\n    Args:\r\n    ----\r\n        error_instances (list, optional): A list of instances in an error state to delete.\r\n                                           If None, the function will find all instances in an error state.\r\n\r\n    Returns:\r\n    -------\r\n        list: A list of instances that were in an error state and have been deleted.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    error_instances: list[Server]  # Hack to avoid type error\r\n    logger.info(\&quot;Deleting all error instances\&quot;)\r\n    if not error_instances:\r\n        error_instances = find_error_instances()\r\n    for instance in error_instances:\r\n        if instance.status == \&quot;ERROR\&quot;:\r\n            delete_instance(instance)\r\n            logger.info(f\&quot;Deleted instance '{instance.name}'\&quot;)\r\n    return error_instances\r\n\r\n\r\n@dataclass\r\nclass Instance:\r\n    \&quot;\&quot;\&quot;\r\n    A data class that represents an instance.\r\n\r\n    This class is used to store the name and status of an instance. It's a simple data holder\r\n    and doesn't contain any methods.\r\n\r\n    Attributes\r\n    ----------\r\n    name : str\r\n        The name of the instance.\r\n    status : str\r\n        The status of the instance.\r\n\r\n    \&quot;\&quot;\&quot;\r\n\r\n    name: str\r\n    status: str\r\n\r\n\r\ndef generate_instance_list(\r\n    gpu_model: str,\r\n    gpu_count: int = 1,\r\n    first_instance_number: int = 1,\r\n    last_instance_number: int = 99,\r\n) -&gt; list[Instance]:\r\n    \&quot;\&quot;\&quot;\r\n    Generate a list of instances with the specified parameters.\r\n\r\n    Returns\r\n    -------\r\n    list[NamedTuple]: A list of instances with the specified parameters.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    instances = []\r\n    for instance_number in range(first_instance_number, last_instance_number + 1):\r\n        instance_name = get_instance_name(gpu_model, gpu_count, instance_number)\r\n        instance = Instance(name=instance_name, status=\&quot;NONEXISTING\&quot;)\r\n        instances.append(instance)\r\n    return instances\r\n\r\n\r\nFIRST_INSTANCE_NUMBER = 0\r\nLAST_INSTANCE_NUMBER = 99\r\nlist_4090_instances = generate_instance_list(\&quot;4090\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_3080_instances = generate_instance_list(\&quot;3080\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_2080ti_instances = generate_instance_list(\&quot;2080Ti\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_3090_instances = generate_instance_list(\&quot;3090\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\nlist_5000_instances = generate_instance_list(\&quot;5000\&quot;, 1, FIRST_INSTANCE_NUMBER, LAST_INSTANCE_NUMBER)\r\n\r\n\r\ndef print_instance_statuses(instance_type: str, instances: list[Instance]) -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Print the statuses of instances in a visual format.\r\n\r\n    Parameters\r\n    ----------\r\n    instance_type : str\r\n        The type of the instances. This is printed at the start of the line.\r\n    instances : list[Instance]\r\n        The list of instances whose statuses are to be printed.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    print(f\&quot;{instance_type}:\&quot;, end=\&quot;\&quot;)  # noqa: T201\r\n    for index, instance in enumerate(instances):\r\n        if index % 10 == 0:\r\n            print(\&quot; \&quot;, end=\&quot;\&quot;)  # noqa: T201\r\n        status_symbols = {\r\n            \&quot;ACTIVE\&quot;: \&quot;â–ˆ\&quot;,\r\n            \&quot;ERROR\&quot;: \&quot;\\033[1m\\033[31mE\\033[0m\&quot;,\r\n            \&quot;SHUTOFF\&quot;: \&quot;S\&quot;,\r\n            \&quot;BUILD\&quot;: \&quot;B\&quot;,\r\n            \&quot;NONEXISTING\&quot;: \&quot;Â·\&quot;,\r\n        }\r\n        print(status_symbols.get(instance.status, \&quot;?\&quot;), end=\&quot;\&quot;)  # noqa: T201\r\n    print()  # noqa: T201\r\n\r\n\r\n@app.command()\r\ndef get_overview(server_list=None) -&gt; list[Server]:  # type: ignore[override]  # noqa: ANN001\r\n    \&quot;\&quot;\&quot;\r\n    Retrieve an overview of all the instances in the OpenStack environment.\r\n\r\n    It categorizes the instances based on the flavor (type of instance) and updates the status of each instance.\r\n    The function also prints a visual representation of the instances' statuses.\r\n\r\n    Returns\r\n    -------\r\n    list[openstack.compute.v2.server.Server]: A list of all servers in the OpenStack environment.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    server_list: list[Server]  # Hack to avoid type error\r\n    servers = server_list or refresh_instance_list()\r\n    logger.info(\&quot;Overview of instances:\&quot;)\r\n    print(\&quot;     \&quot;, \&quot;0\&quot; * 10, \&quot;1\&quot; * 10, \&quot;2\&quot; * 10, \&quot;3\&quot; * 10, \&quot;4\&quot; * 10, \&quot;5\&quot; * 10, \&quot;6\&quot; * 10, \&quot;7\&quot; * 10, \&quot;8\&quot; * 10, \&quot;9\&quot; * 10)  # noqa: T201 WPS221\r\n    print(\&quot;      \&quot;, \&quot;0123456789 \&quot; * 10, sep=\&quot;\&quot;)  # noqa: T201\r\n    print_instance_statuses(\&quot;4090\&quot;, list_4090_instances)\r\n    print_instance_statuses(\&quot;3080\&quot;, list_3080_instances)\r\n    print_instance_statuses(\&quot;3090\&quot;, list_3090_instances)\r\n    print_instance_statuses(\&quot;5000\&quot;, list_5000_instances)\r\n    return servers\r\n\r\n\r\ndef refresh_instance_list() -&gt; list[Server]:\r\n    \&quot;\&quot;\&quot;\r\n    Refresh the list of instances in the OpenStack environment.\r\n\r\n    This function retrieves the OpenStack connection and lists all servers (instances).\r\n    It then iterates over each server and checks the flavor (type) of the server.\r\n    Depending on the flavor, it updates the corresponding list of instances with the server's information.\r\n\r\n    Returns\r\n    -------\r\n    list[Server]\r\n        A list of all servers in the OpenStack environment.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    logger.debug(\&quot;Loading servers list...\&quot;)\r\n    conn = OpenStackConnection.instance()\r\n    servers: list[Server] = conn.list_servers(bare=True)  # type: ignore[assignment]\r\n    for server in servers:\r\n        flavor: Flavor | None | Any = server.flavor\r\n        if not flavor:\r\n            continue\r\n        if flavor.name in {flavor_name_4090, flavor_name_4090_aux}:\r\n            update_list_of_instances(list_4090_instances, server)\r\n        elif flavor.name == flavor_name_3080:\r\n            update_list_of_instances(list_3080_instances, server)\r\n        elif flavor.name in {flavor_name_3090, flavor_name_3090_aux}:\r\n            update_list_of_instances(list_3090_instances, server)\r\n        elif flavor.name == flavor_name_5000:\r\n            update_list_of_instances(list_5000_instances, server)\r\n    return servers\r\n\r\n\r\ndef update_list_of_instances(instances: list[Instance], server: Server) -&gt; bool | None:\r\n    \&quot;\&quot;\&quot;\r\n    Update the status of instances in the provided list based on the server's status.\r\n\r\n    This function iterates over the provided list of instances and checks if the name of each instance matches\r\n    the name of the provided server. If a match is found, the status of the instance is updated to match the\r\n    status of the server.\r\n\r\n    Args:\r\n    ----\r\n        instances (list[Instance]): A list of instances whose status needs to be updated.\r\n        server (openstack.compute.v2.server.Server): The server whose status is used to update the instances.\r\n\r\n    Returns:\r\n    -------\r\n        bool: True if an instance's status was updated, otherwise None.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    for instance in instances:\r\n        logger.trace(f\&quot;Checking instance '{instance.name}'\&quot;)\r\n        logger.trace(f\&quot;Server name: '{server.name}'\&quot;)\r\n        if instance.name == server.name:\r\n            logger.trace(f\&quot;Updating instance '{server.name}'\&quot;)\r\n            instance.status = str(server.status)\r\n            return True\r\n    return None\r\n\r\n\r\ndef find_available_server_slots(instance_list: list[Instance]) -&gt; list[int]:\r\n    \&quot;\&quot;\&quot;\r\n    Find the available server slots in the provided instance list.\r\n\r\n    This function refreshes the instance list and returns a list of available server slots.\r\n    A server slot is considered available if the instance status is \&quot;NONEXISTING\&quot;\r\n    and the instance name does not end with \&quot;-00\&quot;.\r\n    The function returns the instance numbers of the available slots.\r\n\r\n    Args:\r\n    ----\r\n        instance_list (list[Instance]): A list of instances to check for available server slots.\r\n\r\n    Returns:\r\n    -------\r\n        list[int]: A list of available server slot numbers.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    refresh_instance_list()\r\n    return [\r\n        int(instance.name[-2:])  # The instance number from the name\r\n        for instance in instance_list\r\n        if instance.status == \&quot;NONEXISTING\&quot; and not instance.name.endswith(\&quot;-00\&quot;)\r\n    ]\r\n\r\n\r\n@functools.lru_cache\r\ndef get_local_networks() -&gt; tuple[Network, list[Network]] | None:\r\n    \&quot;\&quot;\&quot;\r\n    Retrieve the local network and gateway networks.\r\n\r\n    This function retrieves the local network by its name \&quot;NAS-LAN\&quot; and also calls the function get_gateway_networks()\r\n    to retrieve the gateway networks. Both the local network and gateway networks are returned.\r\n\r\n    Args:\r\n    ----\r\n        conn (openstack.connection.Connection): The OpenStack connection object used to interact with the OpenStack API.\r\n\r\n    Returns:\r\n    -------\r\n        tuple: A tuple containing the local network and the gateway networks.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    logger.info(\&quot;Getting local network\&quot;)\r\n    conn = OpenStackConnection.instance()\r\n    local_network: Network | None = conn.get_network(LAN_NAME)\r\n    if not local_network:\r\n        logger.error(f\&quot;Local network '{LAN_NAME}' not found\&quot;)\r\n        return None\r\n    gateway_networks = get_gateway_networks()\r\n    return local_network, gateway_networks\r\n\r\n\r\n@app.command()\r\ndef create_new_instances(gpu_model: str = \&quot;4090\&quot;, instance_count: int = 50) -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Create new instances based on the provided GPU model and instance count.\r\n\r\n    This function retrieves the OpenStack connection and checks the GPU model.\r\n    If the GPU model is either \&quot;4090\&quot; or \&quot;3090\&quot;, it sets the GPU count, flavor of choice, and instance list accordingly.\r\n    If the GPU model is not recognized, it logs an error and exits.\r\n\r\n\r\n    If any error instances are found during the creation process, it logs an error, deletes all error instances,\r\n    and breaks the loop.\r\n\r\n    Args:\r\n    ----\r\n        gpu_model (str): The model of the GPU. Either \&quot;4090\&quot; or \&quot;3090\&quot;.\r\n        instance_count (int): The number of instances to create.\r\n\r\n    Raises:\r\n    ------\r\n        openstack.exceptions.ResourceNotFound: If the flavor of choice is not found.\r\n        openstack.exceptions.ResourceTimeout: If a timeout occurs when creating an instance.\r\n        openstack.exceptions.SDKException: If any other error occurs when creating an instance.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    # Cloning the base volume into work nodes\r\n    conn = OpenStackConnection.instance()\r\n\r\n    if gpu_model == \&quot;4090\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_4090\r\n        instance_list = list_4090_instances\r\n        gpu_model = \&quot;4090\&quot;\r\n\r\n    elif gpu_model == \&quot;3090\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_3090\r\n        instance_list = list_3090_instances\r\n        gpu_model = \&quot;3090\&quot;\r\n\r\n    elif gpu_model == \&quot;3080\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_3080\r\n        instance_list = list_3080_instances\r\n        gpu_model = \&quot;3080\&quot;\r\n\r\n    elif gpu_model == \&quot;2080Ti\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_2080ti\r\n        instance_list = list_2080ti_instances\r\n        gpu_model = \&quot;2080Ti\&quot;\r\n\r\n    elif gpu_model == \&quot;A5000\&quot;:\r\n        gpu_count = 1\r\n        flavor_of_choice = flavor_name_5000\r\n        instance_list = list_5000_instances\r\n        gpu_model = \&quot;A5000\&quot;\r\n\r\n    else:\r\n        logger.error(f\&quot;GPU model '{gpu_model}' not found\&quot;)\r\n        sys.exit(1)\r\n\r\n    how_many_instances_to_create = instance_count\r\n\r\n    get_local_networks()\r\n    logger.info(f\&quot;Retrieving the flavor: {flavor_of_choice}\&quot;)\r\n    try:\r\n        flavor: Flavor | None = conn.get_flavor(name_or_id=flavor_of_choice)\r\n    except ResourceNotFound:\r\n        logger.error(f\&quot;Flavor '{flavor_of_choice}' not found. Aborting instance creation.\&quot;)\r\n        return\r\n    if not flavor:\r\n        logger.error(\&quot;Flavor lookup went wrong. OpenStack connection might be down.\&quot;)\r\n        return\r\n    logger.info(f\&quot;Found flavor '{flavor.name}'\&quot;)\r\n    available_server_slots = find_available_server_slots(instance_list=instance_list)[:how_many_instances_to_create]\r\n    logger.info(f\&quot;Creating {how_many_instances_to_create} instance(s) with number(s)\&quot; f\&quot; {available_server_slots}\&quot;)\r\n    try:\r\n        for i in available_server_slots:\r\n            create_instance(count_number=i, throwaway=True, flavor=flavor, gpu_model=gpu_model, gpu_count=gpu_count)\r\n            logger.info(f\&quot;Sleeping for {seconds_between_instance_creation} seconds\&quot;)\r\n            sleep(seconds_between_instance_creation)\r\n            error_instances = find_error_instances()\r\n            if error_instances:\r\n                logger.error(f\&quot;Error instances found: {error_instances}\&quot;)\r\n                delete_all_error_instances()\r\n                break\r\n            get_overview()\r\n\r\n    except ResourceTimeout as e:\r\n        logger.error(f\&quot;{e}\&quot;)\r\n    except SDKException as e:\r\n        logger.error(f\&quot;{e}\&quot;)\r\n        delete_all_error_instances()\r\n\r\n\r\n@app.command()\r\ndef create_base_instance(\r\n    gpu_model: str = \&quot;4090\&quot;,\r\n    gpu_count: int = 1,\r\n    flavor_of_choice: str = flavor_name_4090,\r\n) -&gt; Server | None:\r\n    \&quot;\&quot;\&quot;\r\n    Create a base instance with the specified parameters.\r\n\r\n    This function retrieves the OpenStack connection and the flavor of the instance to be created.\r\n    If the flavor is not found, it logs an error and returns.\r\n    If the flavor is found, it creates an instance with the specified parameters.\r\n\r\n    The parameters for the instance are:\r\n    - count_number: 0\r\n    - throwaway: False\r\n    - flavor: The flavor retrieved earlier\r\n    - gpu_model: The GPU model specified as an argument (default is \&quot;4090\&quot;)\r\n    - gpu_count: The number of GPUs specified as an argument (default is 1)\r\n    - volume_name: \&quot;rendernode - base\&quot;\r\n\r\n    Args:\r\n    ----\r\n        gpu_model (str, optional): The model of the GPU. Defaults to \&quot;4090\&quot;.\r\n        gpu_count (int, optional): The number of GPUs. Defaults to 1.\r\n        flavor_of_choice (str, optional): The flavor of the instance. Defaults to flavor_name_4090.\r\n\r\n    Returns:\r\n    -------\r\n        Server | None: The created instance if successful, None otherwise.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    # Get the OpenStack connection instance\r\n    conn = OpenStackConnection.instance()\r\n\r\n    # Get the flavor of the instance to be created\r\n    flavor: Flavor | None = conn.get_flavor(name_or_id=flavor_of_choice)\r\n\r\n    # If the flavor is not found, log an error and return\r\n    if not flavor:\r\n        logger.error(f\&quot;Flavor '{flavor_of_choice}' not found\&quot;)\r\n        return None\r\n\r\n    # If the flavor is found, create an instance with the specified parameters\r\n    return create_instance(\r\n        count_number=0,\r\n        throwaway=False,\r\n        flavor=flavor,\r\n        gpu_model=gpu_model,\r\n        gpu_count=gpu_count,\r\n        volume_name=\&quot;rendernode - base\&quot;,\r\n        wait_for_instance_creation_status=True,\r\n    )\r\n\r\n\r\n@app.command()\r\ndef delete_base_instance() -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Delete the base instance.\r\n\r\n    This function retrieves the OpenStack connection and finds the base instance by its name \&quot;ic-4090-x1-00\&quot;.\r\n    If the base instance is found, it is deleted. If not, a warning is logged.\r\n\r\n    Raises\r\n    ------\r\n        openstack.exceptions.ResourceNotFound: If the base instance is not found.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    # Get the OpenStack connection instance\r\n    conn = OpenStackConnection.instance()\r\n\r\n    # Define the name of the base instance\r\n    instance_name = \&quot;ic-4090-x1-00\&quot;\r\n\r\n    # Find the base instance\r\n    server = conn.compute.find_server(instance_name)\r\n\r\n    # If the base instance is found, delete it\r\n    if server:\r\n        delete_instance(server)\r\n    # If the base instance is not found, log a warning\r\n    else:\r\n        logger.warning(f\&quot;Server {instance_name} is not found\&quot;)\r\n\r\n\r\n@app.command()\r\ndef list_volumes() -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    List all volumes in the OpenStack environment.\r\n\r\n    This function retrieves the OpenStack connection and lists all volumes.\r\n    For each volume, it logs the volume's name and status.\r\n\r\n    The function does not return anything as it's intended for logging purposes.\r\n    \&quot;\&quot;\&quot;\r\n    # Get the OpenStack connection instance\r\n    conn = OpenStackConnection.instance()\r\n\r\n    # List all volumes\r\n    all_volumes = conn.list_volumes()\r\n\r\n    # For each volume, log its name and status\r\n    for volume in all_volumes:\r\n        v = volume.to_dict()\r\n        logger.info(f\&quot;{v['name']:&lt;20}: {v['status']:&lt;20} ID:{v['id']}\&quot;)\r\n\r\n\r\n@app.command()\r\ndef version() -&gt; None:\r\n    \&quot;\&quot;\&quot;Print the current version of the application.\&quot;\&quot;\&quot;\r\n    typer.echo(__version__)\r\n\r\n\r\n@app.command()\r\ndef loop_clean_instances(timeout: int = 15) -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Continuously cleans up stopped and error instances.\r\n\r\n    This function enters an infinite loop where it continuously deletes all stopped and error instances.\r\n    After each cleanup, the function sleeps for a specified timeout period before repeating the process.\r\n\r\n    Args:\r\n    ----\r\n        timeout (int, optional): The number of seconds to sleep after each cleanup. Defaults to 10.\r\n\r\n    \&quot;\&quot;\&quot;\r\n    logger.info(\&quot;Press 'Esc' to exit the loop\&quot;)\r\n    while True:  # noqa: WPS457\r\n        delete_all_stopped_instances()\r\n        delete_all_error_instances()\r\n        with Progress(\r\n            TextColumn(\&quot;[progress.description]{task.description}\&quot;),\r\n            BarColumn(complete_style=\&quot;cyan\&quot;),\r\n            TimeRemainingColumn(),\r\n            transient=True,\r\n        ) as progress:\r\n            timer = progress.add_task(\&quot;[cyan]Sleeping\&quot;, total=timeout)\r\n            timer_update_delay = 0.02\r\n            while not progress.finished:\r\n                progress.update(timer, advance=timer_update_delay)\r\n                sleep(timer_update_delay)\r\n                if keyboard.is_pressed(\&quot;esc\&quot;):\r\n                    logger.success(\&quot;Escape key pressed, exiting...\&quot;)\r\n                    return\r\n\r\n\r\n@app.command()\r\ndef check_if_4090_is_available():\r\n    \&quot;\&quot;\&quot;Check if there are available slots for 4090 instances.\&quot;\&quot;\&quot;\r\n    from al_ic import check_avaliability\r\n\r\n    check_avaliability.check_if_4090_is_available()\r\n\r\n\r\n@app.command()\r\ndef main() -&gt; None:\r\n    \&quot;\&quot;\&quot;\r\n    Old UI flow. Retained for a while in case new UI breaks.\r\n\r\n    This function provides a command-line interface to perform various operations on instances such as:\r\n    - Deleting all stopped instances\r\n    - Deleting all error instances\r\n    - Creating new instances\r\n    - Refreshing the overview of instances\r\n    - Creating a base instance for updating credentials\r\n    - Deleting the base instance after updating credentials\r\n    - Deleting all throwaway volumes\r\n    - Listing all volumes\r\n\r\n    Each operation is confirmed by the user before it is performed.\r\n    \&quot;\&quot;\&quot;\r\n    if typer.confirm(\&quot;Delete all stopped instances?\&quot;):\r\n        delete_all_stopped_instances()\r\n    if typer.confirm(\&quot;Delete all error instances?\&quot;):\r\n        delete_all_error_instances()\r\n    if typer.confirm(\&quot;Create new instances?\&quot;):\r\n        instance_count = 50\r\n        create_new_instances(\&quot;4090\&quot;, instance_count)\r\n    while True:\r\n        get_overview()\r\n        if not typer.confirm(\&quot;Refresh instances?\&quot;):\r\n            break\r\n    if typer.confirm(\&quot;Create base instance for updating credentials\&quot;):\r\n        create_base_instance()\r\n    if typer.confirm(\&quot;Delete base instance after updating credentials\&quot;):\r\n        delete_base_instance()\r\n    if typer.confirm(\&quot;Delete all throwaway volumes?\&quot;):\r\n        delete_throwaway_volumes()\r\n    if typer.confirm(\&quot;list all volumes?\&quot;):\r\n        list_volumes()\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\__init__.py\nFile Content:\n```py\r\n\&quot;\&quot;\&quot;Amber Light Immers.Cloud manager.\&quot;\&quot;\&quot;\r\n# SPDX-FileCopyrightText: 2024-present Mike Talalaevskiy &lt;mital@amber-light.de&gt;\r\n#\r\n# SPDX-License-Identifier: MIT\r\n\r\nfrom al_ic import main\r\nfrom al_ic.__about__ import __version__\r\n\r\n__all__ = [\&quot;main\&quot;, \&quot;__version__\&quot;]\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\__main__.py\nFile Content:\n```py\r\n\&quot;\&quot;\&quot;Entry point for the CLI application.\&quot;\&quot;\&quot;\r\n\r\nfrom al_ic.main import app\r\n\r\nif __name__ == \&quot;__main__\&quot;:\r\n    app()\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\__about__.py\nFile Content:\n```py\r\n# SPDX-FileCopyrightText: 2024-present Mike Talalaevskiy &lt;mital@amber-light.de&gt;\r\n#\r\n# SPDX-License-Identifier: MIT\r\n__version__ = \&quot;0.2.5\&quot;\r\n```\n\nFile Path: P:\\Python\\al-ic\\src\\al_ic\\check_avaliability.py\nFile Content:\n```py\r\nfrom pathlib import Path\r\nfrom time import sleep\r\n\r\nimport pygame\r\nimport requests\r\nfrom loguru import logger\r\nfrom rich.progress import BarColumn, Progress, TextColumn, TimeRemainingColumn\r\n\r\n\r\ndef check_flavor_availability():\r\n    url = \&quot;http://immers.cloud/apiv2/flavor/is-available/\&quot;\r\n    params = {\&quot;id\&quot;: \&quot;1031\&quot;, \&quot;destinationType\&quot;: \&quot;volume\&quot;}\r\n    headers = {\r\n        \&quot;Accept\&quot;: \&quot;application/json\&quot;,\r\n        \&quot;access-token\&quot;: \&quot;JbegAKn3tkNkfkab3iefkNkaefb\&quot;,\r\n    }\r\n\r\n    try:\r\n        response = requests.get(url, headers=headers, params=params)\r\n        response.raise_for_status()  # Raises an HTTPError for bad responses\r\n        return response.text\r\n    except requests.RequestException as e:\r\n        logger.error(f\&quot;An error occurred: {e}\&quot;)\r\n        return None\r\n\r\n\r\ndef beep_if_available(content):\r\n    if \&quot;1\&quot; in content:\r\n        try:\r\n            logger.success(\&quot;Flavor is available!\&quot;)\r\n            pygame.mixer.init()\r\n            pygame.mixer.music.load(\r\n                Path(__file__).parent.resolve() / \&quot;Windows XP Feed Discovered.wav\&quot;,\r\n            )  # Ensure you have a beep.mp3 file\r\n            pygame.mixer.music.play()\r\n            while pygame.mixer.music.get_busy():  # Wait for the sound to finish playing\r\n                pygame.time.Clock().tick(10)\r\n\r\n        except Exception as e:\r\n            logger.error(f\&quot;Failed to play sound: {e}\&quot;)\r\n    else:\r\n        logger.info(\&quot;Flavor is not available\&quot;)\r\n\r\n\r\ndef check_if_4090_is_available():\r\n    while True:  # noqa: WPS457\r\n        logger.info(\&quot;Checking flavor availability...\&quot;)\r\n        content = check_flavor_availability()\r\n        if content:\r\n            beep_if_available(content)\r\n        timeout = 10\r\n\r\n        with Progress(\r\n            TextColumn(\&quot;[progress.description]{task.description}\&quot;),\r\n            BarColumn(complete_style=\&quot;cyan\&quot;),\r\n            TimeRemainingColumn(),\r\n            transient=True,\r\n        ) as progress:\r\n            timer = progress.add_task(\&quot;[cyan]Sleeping\&quot;, total=timeout)\r\n            timer_update_delay = 0.02\r\n            while not progress.finished:\r\n                progress.update(timer, advance=timer_update_delay)\r\n                sleep(timer_update_delay)\r\n                # if keyboard.is_pressed(\&quot;esc\&quot;):\r\n                #     logger.success(\&quot;Escape key pressed, exiting...\&quot;)\r\n                #     return\r\n\r\n\r\nif __name__ == \&quot;__main__\&quot;:\r\n    check_if_4090_is_available()\r\n```\n\nQuestion: What can you tell me about this project. What issues and technical debt do you see?&quot;,&quot;id&quot;:&quot;138c6745-2228-43a1-a03e-11baed317b2f&quot;,&quot;response&quot;:&quot;This project is a command-line interface (CLI) application for managing OpenStack resources, specifically designed to handle instances and volumes related to GPU models. It uses several external libraries such as `typer` for CLI commands, `loguru` for logging, `openstack` SDK for interacting with OpenStack, and `rich` for progress bars.\n\n### Issues and Technical Debt\n\n1. **Code Duplication**:\n   - There are multiple places where similar logic is repeated, such as in the `create_instance` and `create_new_instances` functions. This can be refactored to reduce redundancy.\n\n2. **Error Handling**:\n   - Error handling is present but could be more robust. For example, in `create_new_instances`, if an error occurs, it logs the error but does not provide a mechanism to retry or handle specific types of errors differently.\n\n3. **Hardcoded Values**:\n   - Several hardcoded values like `flavor_name_4090`, `LAN_NAME`, and `seconds_between_instance_creation` are scattered throughout the code. These should be moved to a configuration file or environment variables.\n\n4. **Logging**:\n   - While `loguru` is used for logging, there are some inconsistencies in log levels and messages. For instance, some critical operations use `logger.info` instead of `logger.error` or `logger.warning`.\n\n5. **Type Annotations**:\n   - Type annotations are used inconsistently. Some functions have type hints, while others do not. Consistent use of type hints would improve code readability and maintainability.\n\n6. **Function Complexity**:\n   - Some functions, like `create_instance` and `create_new_instances`, are quite long and complex. Breaking them down into smaller, more manageable functions would improve readability and maintainability.\n\n7. **Documentation**:\n   - While docstrings are present, they could be more detailed, especially for complex functions. Additionally, there is no overall project documentation or README file explaining how to set up and run the project.\n\n8. **Testing**:\n   - There is no indication of unit tests or integration tests. Adding tests would help ensure the reliability and stability of the codebase.\n\n9. **Dependency Management**:\n   - The project relies on several external libraries, but there is no mention of a `requirements.txt` or `Pipfile` for managing these dependencies.\n\n10. **Singleton Pattern**:\n    - The `OpenStackConnection` class uses a singleton pattern, which is generally fine, but it could be improved by using thread-safe mechanisms to ensure it works correctly in multi-threaded environments.\n\n11. **Magic Numbers and Strings**:\n    - The code contains magic numbers and strings, such as status symbols in `print_instance_statuses`. These should be defined as constants to improve readability and maintainability.\n\n12. **Unused Imports and Variables**:\n    - There are some unused imports and variables, such as `sys` and `functools.lru_cache` in `main.py`. These should be removed to clean up the code.\n\n### Recommendations\n\n- **Refactor Code**: Break down large functions into smaller, reusable functions. Remove duplicate code.\n- **Improve Error Handling**: Implement more robust error handling and consider adding retry mechanisms.\n- **Configuration Management**: Move hardcoded values to a configuration file or environment variables.\n- **Consistent Logging**: Standardize logging levels and messages.\n- **Type Annotations**: Use type annotations consistently across the codebase.\n- **Documentation**: Add detailed docstrings and a README file.\n- **Testing**: Implement unit tests and integration tests.\n- **Dependency Management**: Add a `requirements.txt` or `Pipfile`.\n- **Singleton Pattern**: Ensure the singleton pattern is thread-safe.\n- **Constants**: Define magic numbers and strings as constants.\n- **Clean Up**&quot;,&quot;userMessage&quot;:&quot;What can you tell me about this project. What issues and technical debt do you see?&quot;,&quot;serpResults&quot;:null,&quot;referencedFilePaths&quot;:[&quot;P:\\Python\\al-ic\\src\\al_ic\\main.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\__init__.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\__main__.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\__about__.py&quot;,&quot;P:\\Python\\al-ic\\src\\al_ic\\check_avaliability.py&quot;],&quot;imageFilePath&quot;:null}],&quot;clientCode&quot;:&quot;chat.completion&quot;,&quot;model&quot;:&quot;gpt-4o&quot;,&quot;createdOn&quot;:[2024,5,19,13,30,49,504011500],&quot;updatedOn&quot;:[2024,5,19,13,33,59,368606500],&quot;discardTokenLimit&quot;:false}" />
  </component>
</application>